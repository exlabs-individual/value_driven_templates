{"version":3,"file":"static/webpack/static/development/pages/about.js.798ef45ccabe6c858742.hot-update.js","sources":["webpack:///./src/ui/smooth-scroll-container/smooth-scroll-container.component.jsx"],"sourcesContent":["import React from 'react';\nimport throttle from 'lodash.throttle';\n\nconst PAGE_HEIGHT_DEFAULT = '200vh';\n\nexport default class FullPage extends React.Component {\n  constructor(props) {\n    super(props);\n    // throttle so we can rest easy.\n    this.handleScroll = throttle(this.handleScroll, props.throttle);\n  }\n\n  state = {\n    position: this.POSITIONS.top,\n    visible: [],\n  };\n\n  nodes = [];\n\n  componentDidMount() {\n    // Mount scroll listener, and invoke once to set.\n    this.handleScroll();\n    document.addEventListener('scroll', this.handleScroll);\n  }\n\n  componentWillUnmount() {\n    // Unmount scroll listener.\n    document.removeEventListener('scroll', this.handleScroll);\n  }\n\n  get POSITIONS() {\n    return {\n      top: 'top',\n      middle: 'middle',\n      bottom: 'bottom',\n    };\n  }\n\n  capitalize(val) {\n    return val.charAt(0).toUpperCase() + val.substr(1);\n  }\n\n  get styles() {\n    const { position } = this.state;\n\n    return {\n      container: {\n        position: 'relative',\n        width: '100vw',\n        border: '1px solid red',\n      },\n      fixed: {\n        position: position === this.POSITIONS.middle ? 'fixed' : 'absolute',\n        height: '100vh',\n        width: '100vw',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        left: 0,\n        right: 0,\n        top: position === this.POSITIONS.bottom ? 'auto' : '0',\n        bottom: position === this.POSITIONS.bottom ? '0' : 'auto',\n      },\n      page: (pageHeight) => ({\n        height: pageHeight,\n        position: 'relative',\n      }),\n      debug: (direction) => {\n        const getBorderDirectionProp = (prop) =>\n          `border${this.capitalize(direction)}${this.capitalize(prop)}`;\n\n        return {\n          [direction]: 0,\n          width: '100%',\n          position: 'absolute',\n          border: 0,\n          padding: '6px',\n          [getBorderDirectionProp('color')]: 'green',\n          [getBorderDirectionProp('width')]: '1px',\n          [getBorderDirectionProp('style')]: 'solid',\n          borderStyle: 'solid',\n          color: 'green',\n          fontSize: '10px',\n        };\n      },\n    };\n  }\n\n  get position() {\n    const rect = this.node.getBoundingClientRect();\n    if (rect.bottom <= window?.innerHeight) {\n      return this.POSITIONS.bottom;\n    } else if (\n      (rect.top < 0 && rect.bottom > 0) ||\n      (rect.top > 0 && rect.bottom < 0)\n    ) {\n      return this.POSITIONS.middle;\n    } else {\n      return this.POSITIONS.top;\n    }\n  }\n\n  get visible() {\n    const windowHeight = window.innerHeight;\n    return this.nodes.map((el, i) => {\n      const rect = el.getBoundingClientRect();\n      return rect.top < windowHeight && rect.bottom > 0;\n    });\n  }\n\n  handleScroll = () => {\n    this.setState({ visible: this.visible, position: this.position });\n  };\n\n  getPageHeight(i) {\n    const { pageHeight } = this.props;\n    return typeof pageHeight === 'string'\n      ? pageHeight\n      : Array.isArray(pageHeight)\n      ? pageHeight[i] || PAGE_HEIGHT_DEFAULT\n      : PAGE_HEIGHT_DEFAULT;\n  }\n\n  isOnlyVisible = (i) => {\n    const visible = this.visible.filter((v) => v);\n    return visible.length === 1 && this.visible[i];\n  };\n\n  render() {\n    return (\n      <div style={this.styles.container} ref={(el) => (this.node = el)}>\n        <div>\n          {Array.from({ length: this.props.pages }, (v, i) => {\n            const pageHeight = this.getPageHeight(i);\n            return (\n              <div\n                ref={(el) => (this.nodes[i] = el)}\n                style={this.styles.page(pageHeight)}\n                key={i}\n              >\n                {this.props.debug && (\n                  <section>\n                    <div style={this.styles.debug('top')}>\n                      Page {i} start / {pageHeight}\n                    </div>\n                    <div style={this.styles.debug('bottom')}>\n                      Page {i} end / {pageHeight}\n                    </div>\n                  </section>\n                )}\n              </div>\n            );\n          })}\n        </div>\n\n        <div style={this.styles.fixed}>\n          {this.props.children({\n            ...this.state,\n            isOnlyVisible: this.isOnlyVisible,\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nFullPage.defaultProps = {\n  pages: 3, // How many times to split scroll, useful for animations.\n  pageHeight: PAGE_HEIGHT_DEFAULT, // How tall each page is, auto for automatic\n  throttleMs: 50, // Milliseconds to throttle scroll listener (used for performance)\n  debug: false, // Show lines with breakpoint index\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAFA;AAOA;AACA;AAFA;AACA;AAPA;AACA;AADA;AAyGA;AAAA;AAAA;AAAA;AACA;AACA;AA3GA;AAsHA;AACA;AACA;AACA;AAtHA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAvCA;AAyCA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AAAA;AACA;AAKA;AACA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAFA;AAOA;AACA;AA/JA;AAiKA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AALA;;;;A","sourceRoot":""}